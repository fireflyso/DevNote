监听更新接口，新增一个操作范围字段
全局更新：
1. 监听更新接口是覆盖更新，会将容器传递的监听绑定关系覆盖当前绑定关系，更新时判断如果需要更新的监听中有客户绑定的机器（存在非容器机器），接口返回报错信息（存在冲突风险的监听信息）不进行绑定关系更新
2. 假设容器一开始创建了10个监听，在调用更新接口的时候，只传了其中8个监听的信息，出于覆盖更新的逻辑，网络这边会认为没有传的2个监听都已经失效，会将这两个监听下所有容器绑定的机器进行解绑，如果这两个监听中有客户绑定的机器会进行保留，只解绑容器机器
精确更新：
1. 保持不变
2. 假设容器一开始创建了10个监听，在精确更新接口的时候，只传了其中8个监听的信息，那么只对这八个监听信息进行更新，其余的监听忽略

客户业务：如果客户想要扩容的时候，该SLB下存在手动绑定的云服务器，整个SLB下监听的更新都会失败，重试无用
研发逻辑：
- 单个rs绑定关系的变更需要检查并更新所有绑定关系，接口响应速度慢
- 目前已知的问题就已经导致我们需要设定多条规则，后续还可能有更多复杂的业务场景，耦合到一起导致接口逻辑越发复杂，难以维护，出现bug几率增加

变更操作：
1. 批量创建监听，包括监听和绑定RS，返回监听ID列表和任务ID
2. 批量更新监听信息，监听本身的名称、轮询策略、acl、健康检查、timeout，需要监听ID及其更新信息，返回任务ID
3. 批量绑定RS，需要监听ID和rs ip端口信息
4. 批量解绑RS，需要监听ID和rs ip端口信息

查询接口：
1. 查询SLB信息：不再返回监听信息
2. 提供监听详情查询




{
    "src_interface_id": "3a1b56d3-f4b5-4bb6-8a8b-e4b075cefd43",
    "src_interface_name": "Bundle-Ether16",
    "dst_interface_id": "68a50b49-9563-4623-a7ac-1d4998a60648",
    "dst_interface_name": "Bundle-Ether16",
    "vlan_ids": [
        "03b9da81-f22f-4f34-99fa-e585f69cf5d3"
    ],
    "vlans": [
        2495
    ],
    "pipes": [
        "8ee6621e-f22e-11ec-b6e4-8e1561daf06d"
    ]
}



{
    "src_interface_id": "10affbaf-b933-4be8-b1c1-b96bcf15b9e5",
    "src_interface_name": "ae50",
    "dst_interface_id": "c7d2465d-9e7d-4cff-9079-f462d366df29",
    "dst_interface_name": "ae50",
    "vlan_ids": [
        "03b9da81-f22f-4f34-99fa-e585f69cf5d3",
        "7d4e1120-a14d-11ea-84d9-0050569b650a"
    ],
    "vlans": [
        2495,
        2018
    ],
    "pipes": [
        "8ee6621e-f22e-11ec-b6e4-8e1561daf06d",
        "c2fa6b86-ab8b-11ea-9e73-0242ac110002"
    ]
}


UPDATE automatic_product.subinterface SET subinterface_name = 'Bundle-Ether16.2495', interface_id = '0eab9705-2a07-461d-a91a-1cd09ac0e25b' WHERE subinterface_id = '03b9da81-f22f-4f34-99fa-e585f69cf5d3';
UPDATE cdscp.cloud_pipe SET vlan_name = 'Bundle-Ether1022.2145' WHERE id = '671ac238-4951-11ec-bd0a-66ea1f6ee0a6'